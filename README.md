<<<<<<< HEAD
### ë¦¬ë·°ì–´(pushí•œ ì‚¬ëŒ): 
ee
=======
# Quest 02. ê±°ë¶ì´ ë¯¸ë¡œì°¾ê¸°

>ë‚œì´ë„: ğŸŸ¡ğŸŸ¡ğŸŸ¡âšªâšª  
>ì¥ë¥´: ColabTurtlePlus, í•¨ìˆ˜, ì¡°ê±´ë¬¸ í™œìš©  
>>>>>>> b1c4bffdc37456413f6b8f69c3735fe9e51dd0c4

## AIFFEL Campus Online Code Peer Review

- ì½”ë” : ì„œìŠ¹í˜¸  
- ë¦¬ë·°ì–´ : ê¹€ì—°  

## PRT(Peer Review Template)

```

from ColabTurtlePlus.Turtle import * # ColabTurtle ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ Turtle í´ë˜ìŠ¤ë¥¼ import


# ë¯¸ë¡œ ë°ì´í„°
maze = [
    [0, 1, 0, 0, 0],
    [0, 0, 0, 1, 0],
    [0, 1, 1, 0, 0],
    [0, 0, 1, 1, 0],
    [0, 0, 0, 0, 0]
]

# ì‹œì‘ ìœ„ì¹˜ì™€ ëª©ì ì§€ ìœ„ì¹˜
start_x, start_y = 0, 0
end_x, end_y = 4, 4

# í„°í‹€ ì´ˆê¸° ì„¤ì •
window = (100, 100)
initializeTurtle(window, 'logo')
speed(1)

# ë¯¸ë¡œ ì°¾ê¸° ì•Œê³ ë¦¬ì¦˜
def solve_maze(x, y):
    # ëª©ì ì§€ì— ë„ì°©í•œ ê²½ìš°(ì¡°ê±´ë¬¸)
    if x == end_x and y == end_y:
        print("ë¯¸ë¡œë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤") # "ë¯¸ë¡œë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤" ë¼ëŠ” ë¬¸ì¥ì„ ì¶œë ¥í•˜ê³ 
        return True # Trueë¥¼ ë°˜í™˜í•œë‹¤.

    # í˜„ì¬ ìœ„ì¹˜ì—ì„œ ê°ˆ ìˆ˜ ìˆëŠ” ë°©í–¥ íƒìƒ‰
    for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
        nx, ny = x + dx, y + dy
        # ë¯¸ë¡œ ë²”ìœ„(0,0 ~ 4,4) ë‚´ì— ìˆê³ , ê°ˆ ìˆ˜ ìˆëŠ” ê¸¸ì¸ ê²½ìš°
        # maze í–‰ë ¬ì— ìˆ«ì 0ì¸ ë¶€ë¶„ì„ ì°¾ì•„ì„œ ê°ˆ ìˆ˜ ìˆë„ë¡ andë¡œ ì—°ê²°
        if 0 <= nx < 5 and 0 <= ny < 5 and maze[nx][ny] == 0:
            # ê°”ë˜ ê¸¸ í‘œì‹œ
            maze[nx][ny] = 2
            pendown()
            # ë‹¤ìŒ ìœ„ì¹˜ë¡œ ì´ë™
            goto(nx*10, ny*10)  # ê±°ë¶ì´ ë‹¤ìŒ ìœ„ì¹˜ë¡œ ì´ë™

            penup()

            # ì½”ë“œë¥¼ í•´ì„í•´ì£¼ì„¸ìš”!!
            # ì¬ê·€ì ìœ¼ë¡œ ë‹¤ìŒ ì¥ì†Œë¥¼ ì°¾ëŠ” ì½”ë“œë‹¤.
            if solve_maze(nx, ny):
                return True
            else:
                # ë‹¤ì‹œ ì´ì „ìœ¼ë¡œ ëŒì•„ê°€ê¸°
                pendown()
                goto(x * 10, y * 10)
                penup()
                # í‘œì‹œëœ ê¸¸ 0í‘œì‹œ(ì§€ìš°ê¸°)
                maze[nx][ny] = 0


    # ê¸¸ì„ ì°¾ì§€ ëª»í•œ ê²½ìš°
    # "ê¸¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"ë¥¼ ì¶œë ¥í•˜ê³ 
    # Falseë¥¼ ë¦¬í„´

    else:
        print("ê¸¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
        return False
# ì‹œì‘ ìœ„ì¹˜ì—ì„œ ë¯¸ë¡œ ì°¾ê¸° ì‹œì‘
goto(start_x, start_y)
solve_maze(start_x, start_y)
import pprint
pprint.pprint(maze)

````

- [âœ”ï¸]  ** 1. ì£¼ì–´ì§„ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ì™„ì„±ëœ ì½”ë“œê°€ ì œì¶œë˜ì—ˆë‚˜ìš”? **      
- [âœ”ï¸]  ** 2. ì „ì²´ ì½”ë“œì—ì„œ ê°€ì¥ í•µì‹¬ì ì´ê±°ë‚˜ ê°€ì¥ ë³µì¡í•˜ê³  ì´í•´í•˜ê¸° ì–´ë ¤ìš´ ë¶€ë¶„ì— ì‘ì„±ëœ ì£¼ì„ ë˜ëŠ” doc stringì„ ë³´ê³  í•´ë‹¹ ì½”ë“œê°€ ì˜ ì´í•´ë˜ì—ˆë‚˜ìš”? **    
- [âœ”ï¸]  ** 3. ì—ëŸ¬ê°€ ë‚œ ë¶€ë¶„ì„ ë””ë²„ê¹…í•˜ì—¬ ë¬¸ì œë¥¼ â€œí•´ê²°í•œ ê¸°ë¡ì„ ë‚¨ê²¼ê±°ë‚˜â€, â€ìƒˆë¡œìš´ ì‹œë„ ë˜ëŠ” ì¶”ê°€ ì‹¤í—˜ì„ ìˆ˜í–‰â€ í•´ë´¤ë‚˜ìš”? **    
- [âœ”ï¸]  ** 4. íšŒê³ ë¥¼ ì˜ ì‘ì„±í–ˆë‚˜ìš”? **    
- [âœ”ï¸]  ** 5. ì½”ë“œê°€ ê°„ê²°í•˜ê³  íš¨ìœ¨ì ì¸ê°€ìš”? **    

## Review

ë¬¸ì œë¥¼ ì´í•´í•˜ëŠ” ê³¼ì •ì—ì„œ ì‹œê°„ì„ ë§ì´ í• ì• í–ˆë˜ ì €ë¡œì„œëŠ” íš¨ìœ¨ì ì´ê³  ê°„ê²°í•˜ê²Œ ì‘ì„±ëœ ë‹µì•ˆì„ ë³¼ ìˆ˜ ìˆì–´ì„œ ì¢‹ì•˜ìŠµë‹ˆë‹¤.  ê·¸ë£¨ë‹˜ì˜ ì½”ë“œë¥¼ ë³´ë©° ì œ ì½”ë“œì— ëŒ€í•´ ë” ì—°êµ¬í•  ìˆ˜ ìˆì—ˆë˜ ìœ ìµí•œ ê³¼ì œì˜€ìŠµë‹ˆë‹¤.  

